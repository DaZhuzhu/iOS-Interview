## 1. 如何根据线上崩溃日志诊断是否是野指针

### . 概念

已经被释放的对象，其指针没有被置为 nil，依旧指向原来的内存空间。

### . **实践总结：诊断流程**

拿到一份线上崩溃日志后，你可以按以下流程判断：

1. **看异常类型**：是否是 `EXC_BAD_ACCESS (SIGSEGV/SIGBUS)`？ 如果是，进入下一步。

2. **看调用栈顶层**：是否是 `objc_msgSend`, `objc_release`, `objc_retain` 等运行时函数？ 如果是，嫌疑极大。

3. **看错误地址**：是否是 `0xdeadbad00` 等特殊值？ 如果是，基本确诊。

4. **结合调用栈上下文**：即使没有特殊地址，但如果调用栈显示在执行一个看似正常的对象方法调用或释放操作时崩溃，而你的代码看不出问题，也应高度怀疑是野指针。

   ```objective-c
   Exception Type:  EXC_BAD_ACCESS (SIGSEGV)
   Exception Codes: KERN_INVALID_ADDRESS at 0x0000000deadbad00
   Crashed Thread:  0
     
   Thread 0 Crashed:
   0   libobjc.A.dylib               0x00000001c5a8b0b8 objc_msgSend + 16
   1   UIKitCore                     0x00000001a2f45a94 -[UIView setNeedsLayout] + 172
   2   YourApp                       0x0000000100aabbcc -[ViewController viewDidAppear:] (ViewController.m:123)
   ...
   或
   Thread 0 Crashed:
   0   libobjc.A.dylib               0x00000001835590c4 objc_release + 28
   1   CoreFoundation                0x0000000183a0b27c -[__NSArrayI dealloc] + 60
   2   YourApp                       0x0000000100aabbcc -[MyManager dealloc] (MyManager.m:45)
   3   YourApp                       0x0000000100aabc10 -[ViewController setupManager] (ViewController.m:135)
   ...
   ```

   

### . 野指针出现的场景

1. assign 修饰对象（非基本数据类型），assign 修饰的对象不会在释放时将指针置为 nil

2. 多线程导致野指针访问

   例子1 

   ```objective-c
   // 🚨 详细的野指针场景
   @interface DanglingPointerDemo : NSObject
   @property (nonatomic, strong) NSMutableArray *objects;
   @end
   
   @implementation DanglingPointerDemo
   
   - (void)demonstrateDanglingPointer {
   self.objects = [NSMutableArray array];
   
   // 线程1：添加对象
   dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^{
       for (int i = 0; i < 100; i++) {
           // 创建一个临时对象
           NSString *tempString = [[NSString alloc] initWithFormat:@"Object_%d", i];
           [self.objects addObject:tempString];
           // tempString在这里可能被释放（取决于ARC的优化）
       }
   });
   
   // 线程2：移除对象
   dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
       while (YES) {
           if (self.objects.count > 0) {
               // 移除对象，对象的引用计数可能变为0
               [self.objects removeObjectAtIndex:0];
           }
       }
   });
   
   // 线程3：读取（你提到的代码）
   dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0), ^{
       while (YES) {
           @autoreleasepool {
               // 第一个问题：copy操作可能在数组被修改时进行
               NSArray *snapshot = [self.objects copy]; // 可能崩溃或得到损坏的数组 （其实此处也可以直接根据 index 取数组里的值来模拟野指针）
   
               for (NSString *item in snapshot) {
                   // 第二个问题：即使snapshot创建成功，item可能指向已被释放的对象
   
                   // 在多线程环境下，以下情况可能发生：
                   // 1. snapshot创建时，某个字符串对象还存在
                   // 2. 但在访问item时，该对象已经被其他线程的操作释放
                   // 3. item现在是一个野指针
   
                   NSLog(@"Reading: %@", item); // 💥 可能崩溃！
               }
           }
       }
   
   });
   }
   @end
   
   解释：
   // 模拟内存级别的问题
   /*
   时间线分析：
   
   T1: 线程3开始copy操作，获取数组内部指针
       内存状态：[0x1000, 0x2000, 0x3000] (指向三个字符串对象)
   
   T2: 线程2移除第一个对象
       - removeObjectAtIndex:0 被调用
       - 0x1000处的对象引用计数减1
       - 如果引用计数变为0，对象被释放
       - 但copy操作可能已经获取了0x1000这个指针
   
   T3: 线程3的for循环开始执行
       - item = 0x1000 (但这块内存已经被释放)
       - 访问item时发生野指针访问
   
   T4: 💥 崩溃或不可预期的行为
   */
   ```

   例子2

   ```objective-c
   // 🚨 问题代码 - 网络请求回调中的野指针
   @interface BadNetworkViewController : UIViewController
   @property (nonatomic, strong) UIImageView *avatarImageView;
   @end
   
   @implementation BadNetworkViewController
   
   - (void)loadUserAvatar {
     NSString *urlString = @"https://example.com/avatar.jpg";
   
     // 模拟异步网络请求
     dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
   
   
       // 模拟网络延迟
       sleep(3);
   
       // 假设这里获取到了图片数据
       UIImage *avatarImage = [UIImage imageNamed:@"placeholder"];
   
       dispatch_async(dispatch_get_main_queue(), ^{
           // 🚨 野指针风险！3秒后self可能已经被释放
           // 如果用户在网络请求完成前退出了页面
           self.avatarImageView.image = avatarImage; // 可能崩溃
       });
   
     });
   }
   
   - (void)dealloc {
     NSLog(@"NetworkViewController dealloc");
     // 即使控制器被释放，网络请求的回调仍然会执行
   }
   @end
   
   修正版
   // ✅ 安全的网络请求实现
   @interface SafeNetworkViewController : UIViewController
   @property (nonatomic, strong) UIImageView *avatarImageView;
   @property (nonatomic, strong) NSURLSessionDataTask *imageTask;
   @end
   
   @implementation SafeNetworkViewController
   
   - (void)loadUserAvatar {
       // 取消之前的请求
       [self.imageTask cancel];
       
       NSString *urlString = @"https://example.com/avatar.jpg";
       NSURL *url = [NSURL URLWithString:urlString];
       
       __weak typeof(self) weakSelf = self;
       self.imageTask = [[NSURLSession sharedSession] dataTaskWithURL:url completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
           
           if (error) {
               NSLog(@"Request failed: %@", error);
               return;
           }
           
           UIImage *image = [UIImage imageWithData:data];
           
           dispatch_async(dispatch_get_main_queue(), ^{
               __strong typeof(weakSelf) strongSelf = weakSelf;
               if (strongSelf && strongSelf.avatarImageView) {
                   strongSelf.avatarImageView.image = image;
               }
           });
       }];
       
       [self.imageTask resume];
   }
   
   - (void)dealloc {
       [self.imageTask cancel];
       NSLog(@"SafeNetworkViewController dealloc");
   }
   @end
     
   ```

   

### . 辅助工具和技巧

- **启用Zombie Objects**：**这在开发调试阶段是终极武器**。它会在运行时将已释放对象标记为“僵尸”，而不是真正释放它们。当你访问僵尸对象时，会立即获得一个清晰的错误报告，明确指出**你访问了哪个类（本应是）的已释放对象**。这在线上无法使用，但本地必用。
- **Address Sanitizer (ASan)**：Xcode提供的强大内存调试工具。它可以在运行时检测多种内存错误，包括野指针访问。它比Zombies更强大，但对性能影响更大，也更适合在开发调试阶段使用。
- **线上崩溃上报服务**：像Bugly, Firebase Crashlytics等服务会自动对崩溃日志进行分组。如果你看到大量具有上述特征的崩溃被归为同一类，那么很大概率就是同一个野指针问题导致的。

**最后的重要提示**：野指针问题通常是**偶现**的，因为对象被释放后，那块内存可能很快又被其他数据覆盖。这次访问可能崩溃，下次访问可能不崩溃，或者表现出奇怪的行为。这种不确定性正是它难以调试的原因。所以对于线上偶现的 `EXC_BAD_ACCESS` 崩溃，要给予高度重视，并优先使用上述方法进行排查。

### . 解决

没有很好的方法，基本确定野指针后

## 2. 常见崩溃类型（场景）

子线程刷新UI、错误的方法调用（例如nsurl调用length方法，多发生于函数传参类型不对）、数组越界、向数组中插入nil、kvc中给不存在的key设置value、kvo中移除观察者的次数大于注册观察者的次数、 **野指针访问**（测试最难覆盖到，因为它会随机crash）

## 3. 加载大图

利用 ImageIO 框架分块加载，避免瞬时峰值触发OOM。

### Block 捕获对象相关

