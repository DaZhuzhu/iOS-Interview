## 1. 如何根据线上崩溃日志诊断是否是野指针

### . 概念

已经被释放的对象，其指针没有被置为 nil，依旧指向原来的内存空间。

### . **实践总结：诊断流程**

崩溃维度：mach、unix、oc

拿到一份线上崩溃日志后，你可以按以下流程判断：

1. **看异常类型**：是否是 `EXC_BAD_ACCESS (SIGSEGV/SIGBUS)`？ 如果是，进入下一步。

2. **看调用栈顶层**：是否是 `objc_msgSend`, `objc_release`, `objc_retain` 等运行时函数？ 如果是，嫌疑极大。

3. **看错误地址**：是否是 `0xdeadbad00` 等特殊值？ 如果是，基本确诊。

4. **结合调用栈上下文**：即使没有特殊地址，但如果调用栈显示在执行一个看似正常的对象方法调用或释放操作时崩溃，而你的代码看不出问题，也应高度怀疑是野指针。

   ```objective-c
   Exception Type:  EXC_BAD_ACCESS (SIGSEGV)
   Exception Codes: KERN_INVALID_ADDRESS at 0x0000000deadbad00
   Crashed Thread:  0
     
   Thread 0 Crashed:
   0   libobjc.A.dylib               0x00000001c5a8b0b8 objc_msgSend + 16
   1   UIKitCore                     0x00000001a2f45a94 -[UIView setNeedsLayout] + 172
   2   YourApp                       0x0000000100aabbcc -[ViewController viewDidAppear:] (ViewController.m:123)
   ...
   或
   Thread 0 Crashed:
   0   libobjc.A.dylib               0x00000001835590c4 objc_release + 28
   1   CoreFoundation                0x0000000183a0b27c -[__NSArrayI dealloc] + 60
   2   YourApp                       0x0000000100aabbcc -[MyManager dealloc] (MyManager.m:45)
   3   YourApp                       0x0000000100aabc10 -[ViewController setupManager] (ViewController.m:135)
   ...
   ```

   

### . 野指针出现的场景

1. assign 修饰对象（非基本数据类型），assign 修饰的对象不会在释放时将指针置为 nil

2. 多线程导致野指针访问

   例子1 

   ```objective-c
   // 🚨 详细的野指针场景
   @interface DanglingPointerDemo : NSObject
   @property (nonatomic, strong) NSMutableArray *objects;
   @end
   
   @implementation DanglingPointerDemo
   
   - (void)demonstrateDanglingPointer {
   self.objects = [NSMutableArray array];
   
   // 线程1：添加对象
   dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^{
       for (int i = 0; i < 100; i++) {
           // 创建一个临时对象
           NSString *tempString = [[NSString alloc] initWithFormat:@"Object_%d", i];
           [self.objects addObject:tempString];
           // tempString在这里可能被释放（取决于ARC的优化）
       }
   });
   
   // 线程2：移除对象
   dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
       while (YES) {
           if (self.objects.count > 0) {
               // 移除对象，对象的引用计数可能变为0
               [self.objects removeObjectAtIndex:0];
           }
       }
   });
   
   // 线程3：读取（你提到的代码）
   dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0), ^{
       while (YES) {
           @autoreleasepool {
               // 第一个问题：copy操作可能在数组被修改时进行
               NSArray *snapshot = [self.objects copy]; // 可能崩溃或得到损坏的数组 （其实此处也可以直接根据 index 取数组里的值来模拟野指针）
   
               for (NSString *item in snapshot) {
                   // 第二个问题：即使snapshot创建成功，item可能指向已被释放的对象
   
                   // 在多线程环境下，以下情况可能发生：
                   // 1. snapshot创建时，某个字符串对象还存在
                   // 2. 但在访问item时，该对象已经被其他线程的操作释放
                   // 3. item现在是一个野指针
   
                   NSLog(@"Reading: %@", item); // 💥 可能崩溃！
               }
           }
       }
   
   });
   }
   @end
   
   解释：
   // 模拟内存级别的问题
   /*
   时间线分析：
   
   T1: 线程3开始copy操作，获取数组内部指针
       内存状态：[0x1000, 0x2000, 0x3000] (指向三个字符串对象)
   
   T2: 线程2移除第一个对象
       - removeObjectAtIndex:0 被调用
       - 0x1000处的对象引用计数减1
       - 如果引用计数变为0，对象被释放
       - 但copy操作可能已经获取了0x1000这个指针
   
   T3: 线程3的for循环开始执行
       - item = 0x1000 (但这块内存已经被释放)
       - 访问item时发生野指针访问
   
   T4: 💥 崩溃或不可预期的行为
   */
   ```

   例子2

   ```objective-c
   // 🚨 问题代码 - 网络请求回调中的野指针
   @interface BadNetworkViewController : UIViewController
   @property (nonatomic, strong) UIImageView *avatarImageView;
   @end
   
   @implementation BadNetworkViewController
   
   - (void)loadUserAvatar {
     NSString *urlString = @"https://example.com/avatar.jpg";
   
     // 模拟异步网络请求
     dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
   
   
       // 模拟网络延迟
       sleep(3);
   
       // 假设这里获取到了图片数据
       UIImage *avatarImage = [UIImage imageNamed:@"placeholder"];
   
       dispatch_async(dispatch_get_main_queue(), ^{
           // 🚨 野指针风险！3秒后self可能已经被释放
           // 如果用户在网络请求完成前退出了页面
           self.avatarImageView.image = avatarImage; // 可能崩溃
       });
   
     });
   }
   
   - (void)dealloc {
     NSLog(@"NetworkViewController dealloc");
     // 即使控制器被释放，网络请求的回调仍然会执行
   }
   @end
   
   修正版
   // ✅ 安全的网络请求实现
   @interface SafeNetworkViewController : UIViewController
   @property (nonatomic, strong) UIImageView *avatarImageView;
   @property (nonatomic, strong) NSURLSessionDataTask *imageTask;
   @end
   
   @implementation SafeNetworkViewController
   
   - (void)loadUserAvatar {
       // 取消之前的请求
       [self.imageTask cancel];
       
       NSString *urlString = @"https://example.com/avatar.jpg";
       NSURL *url = [NSURL URLWithString:urlString];
       
       __weak typeof(self) weakSelf = self;
       self.imageTask = [[NSURLSession sharedSession] dataTaskWithURL:url completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
           
           if (error) {
               NSLog(@"Request failed: %@", error);
               return;
           }
           
           UIImage *image = [UIImage imageWithData:data];
           
           dispatch_async(dispatch_get_main_queue(), ^{
               __strong typeof(weakSelf) strongSelf = weakSelf;
               if (strongSelf && strongSelf.avatarImageView) {
                   strongSelf.avatarImageView.image = image;
               }
           });
       }];
       
       [self.imageTask resume];
   }
   
   - (void)dealloc {
       [self.imageTask cancel];
       NSLog(@"SafeNetworkViewController dealloc");
   }
   @end
     
   ```

   

### . 辅助工具和技巧

- **启用Zombie Objects**：**这在开发调试阶段是终极武器**。它会在运行时将已释放对象标记为“僵尸”，而不是真正释放它们。当你访问僵尸对象时，会立即获得一个清晰的错误报告，明确指出**你访问了哪个类（本应是）的已释放对象**。这在线上无法使用，但本地必用。
- **Address Sanitizer (ASan)**：Xcode提供的强大内存调试工具。它可以在运行时检测多种内存错误，包括野指针访问。它比Zombies更强大，但对性能影响更大，也更适合在开发调试阶段使用。
- **线上崩溃上报服务**：像Bugly, Firebase Crashlytics等服务会自动对崩溃日志进行分组。如果你看到大量具有上述特征的崩溃被归为同一类，那么很大概率就是同一个野指针问题导致的。

**最后的重要提示**：野指针问题通常是**偶现**的，因为对象被释放后，那块内存可能很快又被其他数据覆盖。这次访问可能崩溃，下次访问可能不崩溃，或者表现出奇怪的行为。这种不确定性正是它难以调试的原因。所以对于线上偶现的 `EXC_BAD_ACCESS` 崩溃，要给予高度重视，并优先使用上述方法进行排查。

### . 解决

没有很好的方法，基本确定野指针后

## 2. 常见崩溃类型（场景）

子线程刷新UI、错误的方法调用（例如nsurl调用length方法，多发生于函数传参类型不对）、数组越界、向数组中插入nil、kvc中给不存在的key设置value、kvo中移除观察者的次数大于注册观察者的次数、 **野指针访问**（测试最难覆盖到，因为它会随机crash）

## 3. 加载大图

利用 ImageIO 框架分块加载，避免瞬时峰值触发OOM。

### Block 捕获对象相关

## 4. 冷启动

| 1. 预处理阶段（Pre-main）              | 系统内核 + dyld | 加载可执行文件、链接动态库、初始化 ObjC 运行时             | 是（启动耗时的主要组成部分）     |
| -------------------------------------- | --------------- | ---------------------------------------------------------- | -------------------------------- |
| 2. 初始化阶段（Initialization）        | 应用进程        | 执行`+load`方法、初始化全局变量 / 单例                     | 是                               |
| 3. 首屏渲染阶段（First Screen Render） | 应用进程        | 执行`applicationDidFinishLaunching`、加载首屏 UI、完成渲染 | 是（判断启动 “完成” 的关键标志） |

```objective-c
#include <mach/mach.h>
#include <mach/mach_time.h>

// 存储启动起始时间（全局变量，确保不被优化）
static uint64_t s_launchStartTime = 0;

// dyld启动时的回调（需通过dyld_register_func_for_add_image注册）
void dyld_callback(const struct mach_header* mh, intptr_t vmaddr_slide) {
    if (s_launchStartTime == 0) {
        // 获取系统绝对时间（单位：纳秒，底层基于CPU时钟，无系统时间偏差）
        s_launchStartTime = mach_absolute_time();
    }
}

// 初始化时注册dyld回调
__attribute__((constructor)) void register_dyld_callback() {
    _dyld_register_func_for_add_image(dyld_callback);
}
```

建议将这段代码放在一个独立的 `.c` 或 `.m` 文件中（例如 `LaunchTimeMonitor.c`），直接加入工程即可，无需关联到任何 Objective-C 类。

**完全自动执行，无需手动调用**，其执行时机在冷启动的最早期阶段，具体流程如下：

1. **内核创建进程后**：系统加载`dyld`（动态链接器）到进程空间，`dyld`开始准备加载 App 的可执行文件（Mach-O）。
2. **执行`constructor`函数**：编译器会将带有 `__attribute__((constructor))` 的函数注册为「进程初始化函数」，`dyld`在加载可执行文件后、执行`main`函数前，会自动调用这些函数。因此 `register_dyld_callback()` 会被自动执行。
3. **注册`dyld`回调**：`register_dyld_callback()` 中调用 `_dyld_register_func_for_add_image` 注册 `dyld_callback`，该回调会在`dyld`加载每个镜像（image，即 Mach-O 文件，包括 App 自身和依赖的动态库）时触发。
4. **记录启动起点**：首次触发`dyld_callback`时（通常是加载 App 自身的 Mach-O 镜像），`s_launchStartTime`会被赋值为`mach_absolute_time()`的返回值，即冷启动的最早可捕获时间点。

### 三、关键机制说明

- **`__attribute__((constructor))`的作用**：这是底层进程初始化机制，优先级高于所有 Objective-C 的`+load`方法和`main`函数，确保在 App 代码执行前完成回调注册。

- **`_dyld_register_func_for_add_image`的作用**：这是`dyld`提供的 API，用于注册一个回调函数，当`dyld`加载任何动态库或可执行文件（镜像）时，都会调用该回调。我们利用它来捕获`dyld`开始工作的时间点。

- **为何能捕获冷启动起点**：冷启动时进程首次创建，`s_launchStartTime`初始值为 0，首次进入`dyld_callback`时会被赋值，之后即使加载其他动态库再次触发回调，也不会重复赋值。

  

## 5. 性能优化指标

- 启动时间（冷启动、热启动）
- 页面渲染时间（ViewController生命周期跟踪）
- 网络请求（拦截和统计请求耗时、成功率）
- 帧率（FPS）监控
- 内存使用情况（内存泄漏、内存增长）
- 卡顿监控（通过监听RunLoop状态）
- 崩溃收集（信号捕获、未捕获异常处理）



- **采集模块**：负责性能数据采集
- **处理模块**：负责数据加工和聚合
- **存储模块**：负责本地数据存储
- **上报模块**：负责数据上传策略
- **配置模块**：负责远程配置管理

```
+-----------------------+
|      业务应用         |
+-----------------------+
|       APM SDK         |
| +-------------------+ |
| |    配置模块        | |←---(拉取远程配置)
| +-------------------+ |
| | +----+ +----+ +----+ |
| | |采集| |采集| |采集| | 
| | |模块| |模块| |模块| | 
| | +----+ +----+ +----+ |
| |      处理模块        | |
| +-------------------+ |
| |      存储模块        | |
| +-------------------+ |
| |      上报模块        | |---(上报数据)→ 服务器
| +-------------------+ |
+-----------------------+
```



