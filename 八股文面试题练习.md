## 一. 如何根据线上崩溃日志诊断是否是野指针

### . 概念

已经被释放的对象，其指针没有被置为 nil，依旧指向原来的内存空间。

### . **实践总结：诊断流程**

崩溃维度：mach、unix、oc

拿到一份线上崩溃日志后，你可以按以下流程判断：

1. **看异常类型**：是否是 `EXC_BAD_ACCESS (SIGSEGV/SIGBUS)`？ 如果是，进入下一步。

2. **看调用栈顶层**：是否是 `objc_msgSend`, `objc_release`, `objc_retain` 等运行时函数？ 如果是，嫌疑极大。

3. **看错误地址**：是否是 `0xdeadbad00` 等特殊值？ 如果是，基本确诊。

4. **结合调用栈上下文**：即使没有特殊地址，但如果调用栈显示在执行一个看似正常的对象方法调用或释放操作时崩溃，而你的代码看不出问题，也应高度怀疑是野指针。

   ```objective-c
   Exception Type:  EXC_BAD_ACCESS (SIGSEGV)
   Exception Codes: KERN_INVALID_ADDRESS at 0x0000000deadbad00
   Crashed Thread:  0
     
   Thread 0 Crashed:
   0   libobjc.A.dylib               0x00000001c5a8b0b8 objc_msgSend + 16
   1   UIKitCore                     0x00000001a2f45a94 -[UIView setNeedsLayout] + 172
   2   YourApp                       0x0000000100aabbcc -[ViewController viewDidAppear:] (ViewController.m:123)
   ...
   或
   Thread 0 Crashed:
   0   libobjc.A.dylib               0x00000001835590c4 objc_release + 28
   1   CoreFoundation                0x0000000183a0b27c -[__NSArrayI dealloc] + 60
   2   YourApp                       0x0000000100aabbcc -[MyManager dealloc] (MyManager.m:45)
   3   YourApp                       0x0000000100aabc10 -[ViewController setupManager] (ViewController.m:135)
   ...
   ```

   

### . 野指针出现的场景

1. assign 修饰对象（非基本数据类型），assign 修饰的对象不会在释放时将指针置为 nil

2. 多线程导致野指针访问

   例子1 

   ```objective-c
   // 🚨 详细的野指针场景
   @interface DanglingPointerDemo : NSObject
   @property (nonatomic, strong) NSMutableArray *objects;
   @end
   
   @implementation DanglingPointerDemo
   
   - (void)demonstrateDanglingPointer {
   self.objects = [NSMutableArray array];
   
   // 线程1：添加对象
   dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^{
       for (int i = 0; i < 100; i++) {
           // 创建一个临时对象
           NSString *tempString = [[NSString alloc] initWithFormat:@"Object_%d", i];
           [self.objects addObject:tempString];
           // tempString在这里可能被释放（取决于ARC的优化）
       }
   });
   
   // 线程2：移除对象
   dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
       while (YES) {
           if (self.objects.count > 0) {
               // 移除对象，对象的引用计数可能变为0
               [self.objects removeObjectAtIndex:0];
           }
       }
   });
   
   // 线程3：读取（你提到的代码）
   dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0), ^{
       while (YES) {
           @autoreleasepool {
               // 第一个问题：copy操作可能在数组被修改时进行
               NSArray *snapshot = [self.objects copy]; // 可能崩溃或得到损坏的数组 （其实此处也可以直接根据 index 取数组里的值来模拟野指针）
   
               for (NSString *item in snapshot) {
                   // 第二个问题：即使snapshot创建成功，item可能指向已被释放的对象
   
                   // 在多线程环境下，以下情况可能发生：
                   // 1. snapshot创建时，某个字符串对象还存在
                   // 2. 但在访问item时，该对象已经被其他线程的操作释放
                   // 3. item现在是一个野指针
   
                   NSLog(@"Reading: %@", item); // 💥 可能崩溃！
               }
           }
       }
   
   });
   }
   @end
   
   解释：
   // 模拟内存级别的问题
   /*
   时间线分析：
   
   T1: 线程3开始copy操作，获取数组内部指针
       内存状态：[0x1000, 0x2000, 0x3000] (指向三个字符串对象)
   
   T2: 线程2移除第一个对象
       - removeObjectAtIndex:0 被调用
       - 0x1000处的对象引用计数减1
       - 如果引用计数变为0，对象被释放
       - 但copy操作可能已经获取了0x1000这个指针
   
   T3: 线程3的for循环开始执行
       - item = 0x1000 (但这块内存已经被释放)
       - 访问item时发生野指针访问
   
   T4: 💥 崩溃或不可预期的行为
   */
   ```

   例子2

   ```objective-c
   // 🚨 问题代码 - 网络请求回调中的野指针
   @interface BadNetworkViewController : UIViewController
   @property (nonatomic, strong) UIImageView *avatarImageView;
   @end
   
   @implementation BadNetworkViewController
   
   - (void)loadUserAvatar {
     NSString *urlString = @"https://example.com/avatar.jpg";
   
     // 模拟异步网络请求
     dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
   
   
       // 模拟网络延迟
       sleep(3);
   
       // 假设这里获取到了图片数据
       UIImage *avatarImage = [UIImage imageNamed:@"placeholder"];
   
       dispatch_async(dispatch_get_main_queue(), ^{
           // 🚨 野指针风险！3秒后self可能已经被释放
           // 如果用户在网络请求完成前退出了页面
           self.avatarImageView.image = avatarImage; // 可能崩溃
       });
   
     });
   }
   
   - (void)dealloc {
     NSLog(@"NetworkViewController dealloc");
     // 即使控制器被释放，网络请求的回调仍然会执行
   }
   @end
   
   修正版
   // ✅ 安全的网络请求实现
   @interface SafeNetworkViewController : UIViewController
   @property (nonatomic, strong) UIImageView *avatarImageView;
   @property (nonatomic, strong) NSURLSessionDataTask *imageTask;
   @end
   
   @implementation SafeNetworkViewController
   
   - (void)loadUserAvatar {
       // 取消之前的请求
       [self.imageTask cancel];
       
       NSString *urlString = @"https://example.com/avatar.jpg";
       NSURL *url = [NSURL URLWithString:urlString];
       
       __weak typeof(self) weakSelf = self;
       self.imageTask = [[NSURLSession sharedSession] dataTaskWithURL:url completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
           
           if (error) {
               NSLog(@"Request failed: %@", error);
               return;
           }
           
           UIImage *image = [UIImage imageWithData:data];
           
           dispatch_async(dispatch_get_main_queue(), ^{
               __strong typeof(weakSelf) strongSelf = weakSelf;
               if (strongSelf && strongSelf.avatarImageView) {
                   strongSelf.avatarImageView.image = image;
               }
           });
       }];
       
       [self.imageTask resume];
   }
   
   - (void)dealloc {
       [self.imageTask cancel];
       NSLog(@"SafeNetworkViewController dealloc");
   }
   @end
     
   ```

   

### . 辅助工具和技巧

- **启用Zombie Objects**：**这在开发调试阶段是终极武器**。它会在运行时将已释放对象标记为“僵尸”，而不是真正释放它们。当你访问僵尸对象时，会立即获得一个清晰的错误报告，明确指出**你访问了哪个类（本应是）的已释放对象**。这在线上无法使用，但本地必用。
- **Address Sanitizer (ASan)**：Xcode提供的强大内存调试工具。它可以在运行时检测多种内存错误，包括野指针访问。它比Zombies更强大，但对性能影响更大，也更适合在开发调试阶段使用。
- **线上崩溃上报服务**：像Bugly, Firebase Crashlytics等服务会自动对崩溃日志进行分组。如果你看到大量具有上述特征的崩溃被归为同一类，那么很大概率就是同一个野指针问题导致的。

**最后的重要提示**：野指针问题通常是**偶现**的，因为对象被释放后，那块内存可能很快又被其他数据覆盖。这次访问可能崩溃，下次访问可能不崩溃，或者表现出奇怪的行为。这种不确定性正是它难以调试的原因。所以对于线上偶现的 `EXC_BAD_ACCESS` 崩溃，要给予高度重视，并优先使用上述方法进行排查。

### . 解决

没有很好的方法，基本确定野指针后

## 二. 崩溃类型及搜集

### 1. 崩溃类型

1. **异常崩溃（Exception）**
   - **说明**：这是最高层、最常见的崩溃类型，通常由应用程序代码中的错误引发。它又分为两种：
     - **Objective-C异常（NSException）**： 这是Objective-C语言层面的异常。通常由向对象发送无法识别的消息（unrecognized selector）、数组越界、插入nil对象、KVC键值编码错误等常见错误引起。
     - **C++异常**： 如果你的代码或第三方库中使用了C++，那么也可能抛出和捕获C++异常。如果未被捕获，同样会导致进程终止。
2. **信号崩溃（Signal / Mach Exception）**
   - **说明**：这是操作系统底层（Unix/Linux）的进程间通信机制，用于通知进程发生了某些严重事件。当应用执行了非法操作时，操作系统会向其发送一个信号（Signal）来终止它。这是比NSException更底层的崩溃机制。
   - **常见信号**：
     - `SIGABRT`： **中止信号**。这是最常见的一个，通常由`NSException`未被捕获而最终转化而来。所以当你看到`SIGABRT`，其根源很可能是一个Objective-C异常。
     - `SIGSEGV`： **段错误信号**。通常由于访问了不属于你的内存地址导致，例如：访问已释放的对象（野指针）、数组越界（严重时）、内存访问权限错误等。
     - `SIGBUS`： **总线错误**。与`SIGSEGV`类似，但通常与硬件或内存地址对齐有关，现在较少见。
     - `SIGILL`： **非法指令**。尝试执行非法的、格式错误的、未知的指令。
     - `SIGTRAP`： **跟踪陷阱**。通常由调试器（如LLDB）或断言（Assertion）失败引发。
3. **Mach异常（Mach Exception）**
   - **说明**：这是 macOS / iOS 系统内核（XNU）最底层的异常机制。所有硬件和操作系统级别的错误（如上述的信号）首先都会表现为一个Mach异常。然后，BSD层会将大多数Mach异常转换为对应的Unix信号（Signal）再传递给进程。
   - **关系**：可以理解为 **Mach异常是因，Signal是果**。`EXC_BAD_ACCESS` (Mach) 经常对应 `SIGSEGV` 或 `SIGBUS` (Signal)。
4. **主线程卡死（Watchdog Timeout）**
   - **说明**：这不是传统意义上的“崩溃”，应用不会立即退出。但如果应用的主线程在规定时间内（通常启动是20秒，界面切换等操作是5秒）未能响应，系统看门狗（Watchdog）会强制终止应用，并产生一个`EXC_CRASH (SIGKILL)`的崩溃报告。常见于主线程执行了同步网络请求、大量耗时计算、死锁等。
5. **内存不足终止（OOM - Out Of Memory）**
   - **说明**：当系统内存压力极大时，iOS的`jetsam`机制会根据应用的优先级，主动终止（杀掉）某些后台或前台应用以释放内存。这个过程应用来不及做任何处理，也不会生成标准的崩溃报告（Crash Report），但会在设备日志中留下一个`JetsamEvent`日志。

------

**可以“一劳永逸”监控所有崩溃的类型**

**答案是：同时监控 `NSException异常` 和 `Unix信号（Signal）`。**

**为什么不是单一类型？**

- **只监控NSException**：无法捕获纯C/C++代码、底层系统调用错误引发的崩溃（如野指针`SIGSEGV`）。
- **只监控Signal**：虽然能捕获绝大多数底层崩溃，但无法以结构化的方式获取`NSException`的详细信息（如异常名称、原因、调用栈）。`SIGABRT`的根源信息就丢失了。

因此，**“NSException + Signal”的组合方案是目前业界公认的、最接近“一劳永逸”的崩溃监控方案**。它能覆盖99%以上的崩溃场景。

**为什么不直接监控Mach异常？**
理论上，在最底层（Mach层）拦截异常是最彻底的。但在非越狱的iOS环境下，直接捕获和处理Mach异常需要非常高的权限，通常只有调试器（如LLDB）才能做到。在沙盒限制下的普通App中，**直接捕获Mach异常非常困难且不稳定**。而Signal是由Mach异常转换而来，且App有权处理（捕获）大部分Signal，因此监控Signal是用户态应用程序更可行和稳定的方案。

------

### 2. 监控“NSException + Signal”

#### 1. 监控NSException异常

利用Objective-C的运行时特性，通过`NSSetUncaughtExceptionHandler`函数注册一个异常处理函数。

```objective-c
// 1. 原始异常处理函数的指针（为了之后调用）
static NSUncaughtExceptionHandler *originalUncaughtExceptionHandler = NULL;

// 2. 自定义的异常处理函数
void MyUncaughtExceptionHandler(NSException *exception) {
    // 收集崩溃信息：名称，原因，堆栈，设备信息等...
    NSArray *callStack = [exception callStackSymbols];
    NSString *reason = [exception reason];
    NSString *name = [exception name];
    
    // 将信息保存到沙盒或上传服务器
    [CrashCollector saveException:exception];

    // 非常重要！调用之前注册的 handler (比如某些第三方库或者系统自己的)
    if (originalUncaughtExceptionHandler) {
        originalUncaughtExceptionHandler(exception);
    }
    
    // 自杀进程
    kill(getpid(), SIGKILL);
}

// 3. 在应用启动时（如AppDelegate中）注册
- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
    // 保存系统或其它第三方库之前注册的 handler
    originalUncaughtExceptionHandler = NSGetUncaughtExceptionHandler();
    // 设置我们自己的 handler
    NSSetUncaughtExceptionHandler(&MyUncaughtExceptionHandler);
    
    // ... 其它代码
    return YES;
}
```



#### 2. 监控Unix信号

通过C函数`sigaction`来为需要监控的信号注册处理函数。

```objective-c
// 需要监控的信号列表
static int monitored_signals[] = {
    SIGABRT,    // 中止
    SIGSEGV,    // 段错误
    SIGBUS,     // 总线错误
    SIGILL,     // 非法指令
    SIGTRAP,    // 跟踪陷阱
    SIGFPE      // 浮点异常
};

// 信号处理函数
void SignalHandler(int signal) {
    // 收集堆栈信息（这里需要手动获取，不像NSException那样方便）
    NSArray *callStack = [CrashCollector backtrace]; // 需要自己实现获取调用栈的函数
    [CrashCollector saveSignal:signal stack:callStack];
    
    // 清理工作，然后终止程序
    kill(getpid(), signal);
}

// 注册信号处理函数
void RegisterSignalHandler(void) {
    struct sigaction action;
    action.sa_handler = &SignalHandler;
    sigemptyset(&action.sa_mask);
    action.sa_flags = SA_ONSTACK | SA_NODEFER; // 重要标志，确保信号处理能正常工作
    
    const int count = sizeof(monitored_signals) / sizeof(int);
    for (int i = 0; i < count; ++i) {
        sigaction(monitored_signals[i], &action, NULL);
    }
}

// 在AppDelegate中调用
- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
    // ... 设置Exception Handler
    RegisterSignalHandler(); // 注册Signal Handler
    return YES;
}
```

### 3. 重要提醒和最佳实践

1. **不要重复造轮子**：自己实现完整的崩溃收集系统非常复杂（尤其是堆栈符号化）。强烈推荐使用成熟的第三方开源库，如：
   - **PLCrashReporter** (Microsoft维护，非常可靠)
   - **KSCrash** (性能最好，功能最强大)
   - 或者使用商业服务如 **Bugly**, **Firebase Crashlytics** 等，它们封装了底层的采集和上报逻辑。
2. **崩溃信息的符号化（Symbolication）**：采集到的崩溃堆栈是内存地址，需要对应的`.dSYM`符号文件才能还原成可读的函数名、行号信息。这是一个独立且复杂的 topic。
3. **多个Handler的协调**：`NSSetUncaughtExceptionHandler`会覆盖之前的handler。如果你的应用使用了其他也会监控崩溃的第三方库（如Firebase），需要注意调用顺序，最好保存并调用之前注册的handler，避免功能冲突。

**总结：**

要实现近乎“一劳永逸”的崩溃监控，**必须同时设置 `NSUncaughtExceptionHandler` 和 `Unix Signal Handler`**。前者捕获OC层面的异常，后者捕获底层系统信号。但这只是数据采集的第一步，后续的存储、符号化、上报同样至关重要。对于大多数开发者而言，选择一个优秀的第三方崩溃收集库是最高效、最稳定的方案。

### 4. 常见崩溃场景

子线程刷新UI、错误的方法调用（例如nsurl调用length方法，多发生于函数传参类型不对）、数组越界、向数组中插入nil、kvc中给不存在的key设置value、kvo中移除观察者的次数大于注册观察者的次数、 **野指针访问**（测试最难覆盖到，因为它会随机crash）

## 三. 加载大图

利用 ImageIO 框架分块加载，避免瞬时峰值触发OOM。

## 四. 冷启动

| 1. 预处理阶段（Pre-main）              | 系统内核 + dyld | 加载可执行文件、链接动态库、初始化 ObjC 运行时             | 是（启动耗时的主要组成部分）     |
| -------------------------------------- | --------------- | ---------------------------------------------------------- | -------------------------------- |
| 2. 初始化阶段（Initialization）        | 应用进程        | 执行`+load`方法、初始化全局变量 / 单例                     | 是                               |
| 3. 首屏渲染阶段（First Screen Render） | 应用进程        | 执行`applicationDidFinishLaunching`、加载首屏 UI、完成渲染 | 是（判断启动 “完成” 的关键标志） |

```objective-c
#include <mach/mach.h>
#include <mach/mach_time.h>

// 存储启动起始时间（全局变量，确保不被优化）
static uint64_t s_launchStartTime = 0;

// dyld启动时的回调（需通过dyld_register_func_for_add_image注册）
void dyld_callback(const struct mach_header* mh, intptr_t vmaddr_slide) {
    if (s_launchStartTime == 0) {
        // 获取系统绝对时间（单位：纳秒，底层基于CPU时钟，无系统时间偏差）
        s_launchStartTime = mach_absolute_time();
    }
}

// 初始化时注册dyld回调
__attribute__((constructor)) void register_dyld_callback() {
    _dyld_register_func_for_add_image(dyld_callback);
}
```

建议将这段代码放在一个独立的 `.c` 或 `.m` 文件中（例如 `LaunchTimeMonitor.c`），直接加入工程即可，无需关联到任何 Objective-C 类。

**完全自动执行，无需手动调用**，其执行时机在冷启动的最早期阶段，具体流程如下：

1. **内核创建进程后**：系统加载`dyld`（动态链接器）到进程空间，`dyld`开始准备加载 App 的可执行文件（Mach-O）。
2. **执行`constructor`函数**：编译器会将带有 `__attribute__((constructor))` 的函数注册为「进程初始化函数」，`dyld`在加载可执行文件后、执行`main`函数前，会自动调用这些函数。因此 `register_dyld_callback()` 会被自动执行。
3. **注册`dyld`回调**：`register_dyld_callback()` 中调用 `_dyld_register_func_for_add_image` 注册 `dyld_callback`，该回调会在`dyld`加载每个镜像（image，即 Mach-O 文件，包括 App 自身和依赖的动态库）时触发。
4. **记录启动起点**：首次触发`dyld_callback`时（通常是加载 App 自身的 Mach-O 镜像），`s_launchStartTime`会被赋值为`mach_absolute_time()`的返回值，即冷启动的最早可捕获时间点。

**关键机制说明**

- **`__attribute__((constructor))`的作用**：这是底层进程初始化机制，优先级高于所有 Objective-C 的`+load`方法和`main`函数，确保在 App 代码执行前完成回调注册。

- **`_dyld_register_func_for_add_image`的作用**：这是`dyld`提供的 API，用于注册一个回调函数，当`dyld`加载任何动态库或可执行文件（镜像）时，都会调用该回调。我们利用它来捕获`dyld`开始工作的时间点。

- **为何能捕获冷启动起点**：冷启动时进程首次创建，`s_launchStartTime`初始值为 0，首次进入`dyld_callback`时会被赋值，之后即使加载其他动态库再次触发回调，也不会重复赋值。

  

## 五. 性能优化指标

- 启动时间（冷启动、热启动）
- 页面渲染时间（ViewController生命周期跟踪）
- 网络请求（拦截和统计请求耗时、成功率）
- 帧率（FPS）监控
- 内存使用情况（内存泄漏、内存增长）
- 卡顿监控（通过监听RunLoop状态）
- 崩溃收集（信号捕获、未捕获异常处理）



- **采集模块**：负责性能数据采集
- **处理模块**：负责数据加工和聚合
- **存储模块**：负责本地数据存储
- **上报模块**：负责数据上传策略
- **配置模块**：负责远程配置管理

```
+-----------------------+
|      业务应用         |
+-----------------------+
|       APM SDK         |
| +-------------------+ |
| |    配置模块        | |←---(拉取远程配置)
| +-------------------+ |
| | +----+ +----+ +----+ |
| | |采集| |采集| |采集| | 
| | |模块| |模块| |模块| | 
| | +----+ +----+ +----+ |
| |      处理模块        | |
| +-------------------+ |
| |      存储模块        | |
| +-------------------+ |
| |      上报模块        | |---(上报数据)→ 服务器
| +-------------------+ |
+-----------------------+
```



